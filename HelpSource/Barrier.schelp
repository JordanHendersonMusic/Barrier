CLASS:: Barrier
summary:: A synchronisation barrier. Will wait until n number of threads have finished.
categories:: Scheduling
related:: Classes/Channel

DESCRIPTION::
An synchronisation barrier.
Evaluates many threads in parralel, will wait for all to be finished.
Barriers are not reuseable.

SECTION:: Usage

There are two ways to use Barrier that can be understood by asking two questions,
do you want to compute a value or do something?
and do you have many functions, or one function you want to evaluate many times?

SUBSECTION:: With or without return value
By using 'collect', 'b.value' will become an array of 4 random numbers between 0 and 1.
code::
r = Routine.run {
	var b  = Barrier.collect(
		{ var v = 1.0.rand; v.wait; v},
		{ var v = 1.0.rand; v.wait; v},
		{ var v = 1.0.rand; v.wait; v},
		{ var v = 1.0.rand; v.wait; v}
	);
	\waiting.postln;
	b.value.postln;
	\done.postln;
}
::
Whereas, when using 'do', the output is ignored.
This particularly useful if you want to spawn a bunch of independed voices in polyphony and wait until all are finished.
code::
r = Routine.run {
	var b  = Barrier.do(
		{ var v = 1.0.rand; v.wait; v.postln},
		{ var v = 1.0.rand; v.wait; v.postln},
		{ var v = 1.0.rand; v.wait; v.postln},
		{ var v = 1.0.rand; v.wait; v.postln}
	);
	\waiting.postln;
	b.wait;
	\done.postln;
}
::

NOTE::
Please note, that 'collect' is followed by a call to '.value', and 'do' is followed by '.wait'.
::

SUBSECTION:: Single function, or repeat
Both 'collect' and 'do' can have variants called 'collectNTimes' and 'doNTimes'.
They repeat the given function 'N' times.

code::
r = Routine.run {
	var b  = Barrier.doNTimes(10,
		{ var v = 1.0.rand; v.wait; v.postln}
	);
	\waiting.postln;
	var b.wait;
	\done.postln;
};

r = Routine.run {
	var b = Barrier.collectNTimes(4,
		{ var v = 1.0.rand; v.wait; v}
	);
	\waiting.postln;
	b.value.postln;
	\done.postln;
};
::



CLASSMETHODS::

METHOD::do

argument:: ...seriesOfFuncs
A series of functions to run.
Ignores return value.
Functions are passed the thread number as the first argument.


METHOD::collect
argument:: ...seriesOfFuncs
A series of functions to run.
Each function's return value is added to an array, accessable with '.value'.
Functions are passed the thread number as the first argument.


METHOD::doNTimes
argument:: n
The number of times to duplicate the function.
argument:: function
A function to do evaluate n times, is passed n as an argument.
Return value is ignored.


METHOD::collectNTimes
argument:: n
The number of times to duplicate the function.
argument:: function
A function to do evaluate n times, is passed n as an argument.
Return value added to an array.


INSTANCEMETHODS::
METHOD:: wait
Only works on a 'do' Barrier. Will wait for the threads to finish

METHOD:: value
Only works on a 'collect' Barrier. Will wait for the threads to finish and return the value.
If this isn't called in a thread, and the value has not been completed then an error will be thrown.
If the value has been completed, it will always return.


METHOD:: isFinished
Returns a boolean, true if all routines have finsished, false if not.

METHOD:: isPlaying
Returns a boolean, true if routines are still playing, false if not.

EXAMPLES::

Below is an interactive example. Run it while reading the code and following the post window.
In short, the main voice plays 5 notes, then 10 other voices play while the main voice is quite,
then the main voice plays 5 more notes, then while 20 other voices play, the main voice also plays something.

code::
(
s.waitForBoot {

	SynthDef(\bleep, {
		var env = Env.perc(\atk.kr(0.01), \rel.kr(1)).ar(doneAction: 2);
		var sig = SinOsc.ar(\freq.kr(220));
		Out.ar(\out.kr(0), sig * env * \amp.kr(0.2)!2);
	}).add;

	s.sync;
	s.scope;

	Routine.run {
		"staring main voice".warn;
		5.do{ |count|
			var delta = 3.0.rand + 0.1;
			var step = Scale.major.semitones.choose;
			var root = 60;
			var freq = (step + root).midicps;

			format("main voice at %", freq).postln;
			Synth(\bleep, [\freq, freq, \rel, delta]);
			if(count != 4, {delta.wait});
		};

		"staring other voices".warn;
		~othervoices1 = Barrier.doNTimes(10, {|n|
			5.do{ |count|
				var delta = 6.0.rand + 3;
				var step = Scale.major.semitones.choose;
				var root = 55;
				var freq = (step + root).midicps;

				format("other voice % at %", n, freq).postln;
				Synth(\bleep, [
					\freq, freq,
					\atk, delta/2,
					\rel, delta/2,
					\amp, 0.1
				]);
				// do not wait for last note to finish.
				if(count != 4, {delta.wait});
			}
		});

		"main voice waits whilst other voices continue".warn;
		~othervoices1.wait;


		"staring main voice again".warn;
		5.do{ |count|
			var delta = 3.0.rand + 3;
			var step = Scale.major.semitones.choose;
			var root = 65;
			var freq = (step + root).midicps;

			format("main voice at %", freq).postln;
			Synth(\bleep, [\freq, freq, \rel, delta]);
			if(count != 4, {delta.wait});
		};

		"staring other voices again".warn;
		~othervoices2 = Barrier.doNTimes(20, { |n|
			25.do{ |count|
				var delta = 3.0.rand + 0.3;
				var step = Scale.major.semitones.choose;
				var root = 63;
				var freq = (step + root).midicps;

				format("other voice % at %", n, freq).postln;
				Synth(\bleep, [
					\freq, freq,
					\atk, delta/2,
					\rel, delta/2,
					\amp, 0.05
				]);
				if(count != 24, {delta.wait});
			}
		});

		"main voice does this while the other voices are playing".warn;
		while({~othervoices2.isPlaying}, {
			var delta = 3.0.rand + 3;
			var step = Scale.major.semitones.choose;
			var root = 40;
			var freq = (step + root).midicps;
			format("main voice at %", freq).postln;
			Synth(\bleep, [
				\freq, freq,
				\rel, delta / 10,
				\amp, 0.6
			]);
			delta.wait;
		});

		"done".warn;
	}
};
)
::





